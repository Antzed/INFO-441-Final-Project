{"version":3,"file":"operation.js","sourceRoot":"","sources":["../../../../../src/lro/operation/operation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AbortSignal } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport {\n  CancelCertificateOperationOptions,\n  CertificateOperation,\n  GetCertificateOptions,\n  GetPlainCertificateOperationOptions,\n  KeyVaultCertificateWithPolicy,\n} from \"../../certificatesModels\";\nimport {\n  cleanState,\n  KeyVaultCertificatePollOperation,\n  KeyVaultCertificatePollOperationState,\n} from \"../keyVaultCertificatePoller\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport {\n  getCertificateOperationFromCoreOperation,\n  getCertificateWithPolicyFromCertificateBundle,\n} from \"../../transformations\";\nimport { tracingClient } from \"../../tracing\";\n\n/**\n * An interface representing the publicly available properties of the state of the CertificateOperationPoller.\n */\nexport interface CertificateOperationState\n  extends KeyVaultCertificatePollOperationState<KeyVaultCertificateWithPolicy> {\n  /**\n   * The operation of the certificate\n   */\n  certificateOperation?: CertificateOperation;\n}\n\n/**\n * An interface representing the active operation of a certificate's creation,\n * which is represented locally as the \"operation\" of an active LRO Poller.\n */\nexport class CertificateOperationPollOperation extends KeyVaultCertificatePollOperation<\n  CertificateOperationState,\n  KeyVaultCertificateWithPolicy\n> {\n  constructor(\n    public state: CertificateOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state);\n  }\n\n  /**\n   * Cancels a certificate creation operation that is already in progress. This operation requires the certificates/update permission.\n   */\n  private cancelCertificateOperation(\n    certificateName: string,\n    options: CancelCertificateOperationOptions = {}\n  ): Promise<CertificateOperation> {\n    return tracingClient.withSpan(\n      \"CertificateOperationPoller.cancelCertificateOperation\",\n      options,\n      async (updatedOptions) => {\n        let parsedBody: any;\n        await this.client.updateCertificateOperation(this.vaultUrl, certificateName, true, {\n          ...updatedOptions,\n          onResponse: (response) => {\n            parsedBody = response.parsedBody;\n          },\n        });\n        return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, parsedBody);\n      }\n    );\n  }\n\n  /**\n   * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.\n   */\n  private getCertificate(\n    certificateName: string,\n    options: GetCertificateOptions = {}\n  ): Promise<KeyVaultCertificateWithPolicy> {\n    return tracingClient.withSpan(\n      \"CertificateOperationPoller.getCertificate\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.getCertificate(\n          this.vaultUrl,\n          certificateName,\n          \"\",\n          updatedOptions\n        );\n        return getCertificateWithPolicyFromCertificateBundle(result);\n      }\n    );\n  }\n\n  /**\n   * Gets the certificate operation.\n   */\n  private getPlainCertificateOperation(\n    certificateName: string,\n    options: GetPlainCertificateOperationOptions = {}\n  ): Promise<CertificateOperation> {\n    return tracingClient.withSpan(\n      \"CertificateOperationPoller.getPlainCertificateOperation\",\n      options,\n      async (updatedOptions) => {\n        let parsedBody: any;\n        await this.client.getCertificateOperation(this.vaultUrl, certificateName, {\n          ...updatedOptions,\n          onResponse: (response) => {\n            parsedBody = response.parsedBody;\n          },\n        });\n        return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, parsedBody);\n      }\n    );\n  }\n\n  /**\n   * Reaches to the service and updates the poll operation.\n   */\n  async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: CertificateOperationState) => void;\n    } = {}\n  ): Promise<CertificateOperationPollOperation> {\n    const state = this.state;\n    const certificateName = state.certificateName!;\n\n    if (options.abortSignal) {\n      this.operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      state.isStarted = true;\n      state.result = await this.getCertificate(certificateName, this.operationOptions);\n      state.certificateOperation = await this.getPlainCertificateOperation(\n        certificateName,\n        this.operationOptions\n      );\n    } else if (!state.isCompleted) {\n      state.certificateOperation = await this.getPlainCertificateOperation(\n        certificateName,\n        this.operationOptions\n      );\n    }\n\n    if (state.certificateOperation && state.certificateOperation.status !== \"inProgress\") {\n      state.isCompleted = true;\n      state.result = await this.getCertificate(certificateName, this.operationOptions);\n      if (state.certificateOperation.error) {\n        state.error = new Error(state.certificateOperation.error.message);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Reaches to the service and cancels the certificate's operation, also updating the poll operation.\n   */\n  async cancel(\n    this: CertificateOperationPollOperation,\n    options: { abortSignal?: AbortSignal } = {}\n  ): Promise<CertificateOperationPollOperation> {\n    const state = this.state;\n    const certificateName = state.certificateName!;\n\n    if (options.abortSignal) {\n      this.operationOptions.abortSignal = options.abortSignal;\n    }\n\n    state.certificateOperation = await this.cancelCertificateOperation(\n      certificateName,\n      this.operationOptions\n    );\n\n    this.state.isCancelled = true;\n    return this;\n  }\n\n  /**\n   * Serializes the certificate's poll operation\n   */\n  public toString(): string {\n    const state: CertificateOperationState = {\n      certificateOperation: this.state.certificateOperation,\n      ...cleanState(this.state),\n    };\n    return JSON.stringify({\n      state,\n    });\n  }\n}\n"]}