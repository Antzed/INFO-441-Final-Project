/// <reference lib="esnext.asynciterable" />

import { AzureLogger } from '@azure/logger';
import * as coreClient from '@azure/core-client';
import { ExtendedCommonClientOptions } from '@azure/core-http-compat';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

/** Defines values for ActionType. */
export declare type ActionType = "EmailContacts" | "AutoRenew";

/**
 * Details of the organization administrator of the certificate issuer.
 */
export declare interface AdministratorContact {
    /**
     * First name.
     */
    firstName?: string;
    /**
     * Last name.
     */
    lastName?: string;
    /**
     * Email address.
     */
    email?: string;
    /**
     * Phone number.
     */
    phone?: string;
}

/**
 * An array with one property at minimum.
 */
export declare type ArrayOneOrMore<T> = {
    0: T;
} & Array<T>;

/**
 * Options for {@link backupCertificate}.
 */
export declare type BackupCertificateOptions = coreClient.OperationOptions;

/** The backup certificate result, containing the backup blob. */
export declare interface BackupCertificateResult {
    /**
     * The backup blob containing the backed up certificate.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: Uint8Array;
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginCreateCertificate}
 */
export declare interface BeginCreateCertificateOptions extends CreateCertificateOptions, CertificatePollerOptions {
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginDeleteCertificate}
 */
export declare type BeginDeleteCertificateOptions = CertificatePollerOptions;

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginRecoverDeletedCertificate}
 */
export declare type BeginRecoverDeletedCertificateOptions = CertificatePollerOptions;

/**
 * Options for {@link cancelCertificateOperation}.
 */
export declare type CancelCertificateOperationOptions = coreClient.OperationOptions;

/**
 * The client to interact with the KeyVault certificates functionality
 */
export declare class CertificateClient {
    /**
     * The base URL to the vault
     */
    readonly vaultUrl: string;
    private readonly client;
    /**
     * Creates an instance of CertificateClient.
     * @param vaultUrl - the base URL to the vault. You should validate that this URL references a valid Key Vault resource. See https://aka.ms/azsdk/blog/vault-uri for details.
     * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \@azure/identity package to create a credential that suits your needs.
     * @param clientOptions - Pipeline options used to configure Key Vault API requests.
     *                          Omit this parameter to use the default pipeline configuration.
     */
    constructor(vaultUrl: string, credential: TokenCredential, clientOptions?: CertificateClientOptions);
    private listPropertiesOfCertificatesPage;
    private listPropertiesOfCertificatesAll;
    /**
     * Iterates the latest version of all certificates in the vault.  The full certificate identifier and attributes are provided
     * in the response. No values are returned for the certificates. This operations requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // All in one call
     * for await (const certificateProperties of client.listPropertiesOfCertificates()) {
     *   console.log(certificateProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfCertificates().byPage()) {
     *   for (const certificateProperties of page) {
     *     console.log(certificateProperties);
     *   }
     * }
     * ```
     * List all versions of the specified certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificates(options?: ListPropertiesOfCertificatesOptions): PagedAsyncIterableIterator<CertificateProperties>;
    private listPropertiesOfCertificateVersionsPage;
    private listPropertiesOfCertificateVersionsAll;
    /**
     * Returns the versions of a certificate in the specified key
     * vault. This operation requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const certificateProperties of client.listPropertiesOfCertificateVersions("MyCertificate")) {
     *   console.log(certificateProperties.version!);
     * }
     * ```
     * List the versions of a certificate.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificateVersions(certificateName: string, options?: ListPropertiesOfCertificateVersionsOptions): PagedAsyncIterableIterator<CertificateProperties>;
    /**
     * The DELETE operation applies to any certificate stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a certificate.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await createPoller.pollUntilDone();
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedCertificate = await deletePoller.pollUntilDone();
     * console.log(deletedCertificate);
     * ```
     * Deletes a certificate from a specified key vault.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    beginDeleteCertificate(certificateName: string, options?: BeginDeleteCertificateOptions): Promise<PollerLike<DeleteCertificateState, DeletedCertificate>>;
    /**
     * Deletes all of the certificate contacts. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * await client.deleteContacts();
     * ```
     * Deletes all of the certificate contacts
     * @param options - The optional parameters
     */
    deleteContacts(options?: DeleteContactsOptions): Promise<CertificateContact[] | undefined>;
    /**
     * Sets the certificate contacts for the key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * ```
     * Sets the certificate contacts.
     * @param contacts - The contacts to use
     * @param options - The optional parameters
     */
    setContacts(contacts: CertificateContact[], options?: SetContactsOptions): Promise<CertificateContact[] | undefined>;
    /**
     * Returns the set of certificate contact resources in the specified key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * const contacts = await client.getContacts();
     * console.log(contacts);
     * ```
     * Sets the certificate contacts.
     * @param options - The optional parameters
     */
    getContacts(options?: GetContactsOptions): Promise<CertificateContact[] | undefined>;
    private listPropertiesOfIssuersPage;
    private listPropertiesOfIssuersAll;
    /**
     * Returns the set of certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * // All in one call
     * for await (const issuerProperties of client.listPropertiesOfIssuers()) {
     *   console.log(issuerProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfIssuers().byPage()) {
     *   for (const issuerProperties of page) {
     *     console.log(issuerProperties);
     *   }
     * }
     * ```
     * List the certificate issuers.
     * @param options - The optional parameters
     */
    listPropertiesOfIssuers(options?: ListPropertiesOfIssuersOptions): PagedAsyncIterableIterator<IssuerProperties>;
    /**
     * The createIssuer operation adds or updates the specified certificate issuer. This
     * operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * ```
     * Sets the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param provider - The issuer provider.
     * @param options - The optional parameters
     */
    createIssuer(issuerName: string, provider: string, options?: CreateIssuerOptions): Promise<CertificateIssuer>;
    /**
     * The updateIssuer operation performs an update on the specified certificate issuer
     * entity. This operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * await client.updateIssuer("IssuerName", {
     *   provider: "Provider2"
     * });
     * ```
     * Updates the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    updateIssuer(issuerName: string, options?: UpdateIssuerOptions): Promise<CertificateIssuer>;
    /**
     * The getIssuer operation returns the specified certificate issuer resources in the
     * specified key vault. This operation requires the certificates/manageissuers/getissuers
     * permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * const certificateIssuer = await client.getIssuer("IssuerName");
     * console.log(certificateIssuer);
     * ```
     * Gets he specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    getIssuer(issuerName: string, options?: GetIssuerOptions): Promise<CertificateIssuer>;
    /**
     * The deleteIssuer operation permanently removes the specified certificate issuer from
     * the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Provider");
     * await client.deleteIssuer("IssuerName");
     * ```
     * Deletes the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    deleteIssuer(issuerName: string, options?: DeleteIssuerOptions): Promise<CertificateIssuer>;
    /**
     * Creates a new certificate. If this is the first version, the certificate resource is created.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * **Note:** Sending `Self` as the `issuerName` of the certificate's policy will create a self-signed certificate.
     *
     * This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const certificatePolicy = {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * };
     * const createPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy);
     *
     * // The pending certificate can be obtained by calling the following method:
     * const pendingCertificate = createPoller.getResult();
     *
     * // Serializing the poller
     * const serialized = createPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy, { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await createPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Creates a certificate
     * @param certificateName - The name of the certificate
     * @param certificatePolicy - The certificate's policy
     * @param options - Optional parameters
     */
    beginCreateCertificate(certificateName: string, policy: CertificatePolicy, options?: BeginCreateCertificateOptions): Promise<PollerLike<CreateCertificateState, KeyVaultCertificateWithPolicy>>;
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificate = await client.getCertificate("MyCertificate");
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name (includes the certificate policy)
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificate(certificateName: string, options?: GetCertificateOptions): Promise<KeyVaultCertificateWithPolicy>;
    /**
     * Gets information about a specific certificate on a specific version. It won't return the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificateWithPolicy = await client.getCertificate("MyCertificate");
     * const certificate = await client.getCertificateVersion("MyCertificate", certificateWithPolicy.properties.version!);
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name and a specified version
     * @param certificateName - The name of the certificate
     * @param version - The specific version of the certificate
     * @param options - The optional parameters
     */
    getCertificateVersion(certificateName: string, version: string, options?: GetCertificateVersionOptions): Promise<KeyVaultCertificate>;
    /**
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format.
     * If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // See: @azure/keyvault-secrets
     * const certificateSecret = await secretClient.getSecret("MyCertificate");
     * const base64EncodedCertificate = certificateSecret.value!;
     * let buffer: Uint8Array;
     *
     * if (isNode) {
     *   buffer = Buffer.from(base64EncodedCertificate, "base64");
     * } else {
     *   buffer = Uint8Array.from(atob(base64EncodedCertificate), (c) => c.charCodeAt(0));
     * }
     *
     * await client.importCertificate("MyCertificate", buffer);
     * ```
     * Imports a certificate from a certificate's secret value
     * @param certificateName - The name of the certificate
     * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key
     * @param options - The optional parameters
     */
    importCertificate(certificateName: string, certificateBytes: Uint8Array, options?: ImportCertificateOptions): Promise<KeyVaultCertificateWithPolicy>;
    /**
     * The getCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const policy = await client.getCertificatePolicy("MyCertificate");
     * console.log(policy);
     * ```
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificatePolicy(certificateName: string, options?: GetCertificatePolicyOptions): Promise<CertificatePolicy>;
    /**
     * Updates the certificate policy for the specified certificate. This operation requires the certificates/update permission.
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param policy - The certificate policy
     * @param options - The optional parameters
     */
    updateCertificatePolicy(certificateName: string, policy: CertificatePolicy, options?: UpdateCertificatePolicyOptions): Promise<CertificatePolicy>;
    /**
     * Applies the specified update on the given certificate; the only elements updated are the
     * certificate's attributes. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     *
     * // You may pass an empty string for version which will update
     * // the latest version of the certificate
     * await client.updateCertificateProperties("MyCertificate", "", {
     *   tags: {
     *     customTag: "value"
     *   }
     * });
     * ```
     * Updates a certificate
     * @param certificateName - The name of the certificate
     * @param version - The version of the certificate to update (an empty string will update the latest version)
     * @param options - The options, including what to update
     */
    updateCertificateProperties(certificateName: string, version: string, options?: UpdateCertificateOptions): Promise<KeyVaultCertificate>;
    /**
     * Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     *
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const pendingCertificate = poller.getResult();
     *
     * const certificateOperation = poller.getOperationState().certificateOperation;
     * console.log(certificateOperation);
     * ```
     * Gets a certificate's poller operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificateOperation(certificateName: string, options?: GetCertificateOperationOptions): Promise<PollerLike<CertificateOperationState, KeyVaultCertificateWithPolicy>>;
    /**
     * Deletes the creation operation for a specified certificate that is in the process of being created.
     * The certificate is no longer created. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await client.deleteCertificateOperation("MyCertificate");
     * await client.getCertificateOperation("MyCertificate"); // Throws error: Pending certificate not found: "MyCertificate"
     * ```
     * Delete a certificate's operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    deleteCertificateOperation(certificateName: string, options?: DeleteCertificateOperationOptions): Promise<CertificateOperation>;
    /**
     * Performs the merging of a certificate or certificate chain with a key pair currently available in the service. This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Unknown",
     *   subject: "cn=MyCert"
     * });
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const { csr } = poller.getOperationState().certificateOperation!;
     * const base64Csr = Buffer.from(csr!).toString("base64");
     * const wrappedCsr = ["-----BEGIN CERTIFICATE REQUEST-----", base64Csr, "-----END CERTIFICATE REQUEST-----"].join("\n");
     *
     * const fs = require("fs");
     * fs.writeFileSync("test.csr", wrappedCsr);
     *
     * // Certificate available locally made using:
     * //   openssl genrsa -out ca.key 2048
     * //   openssl req -new -x509 -key ca.key -out ca.crt
     * // You can read more about how to create a fake certificate authority here: https://gist.github.com/Soarez/9688998
     *
     * const childProcess = require("child_process");
     * childProcess.execSync("openssl x509 -req -in test.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out test.crt");
     * const base64Crt = fs.readFileSync("test.crt").toString().split("\n").slice(1, -1).join("");
     *
     * await client.mergeCertificate("MyCertificate", [Buffer.from(base64Crt)]);
     * ```
     * Merges a signed certificate request into a pending certificate
     * @param certificateName - The name of the certificate
     * @param x509Certificates - The certificate(s) to merge
     * @param options - The optional parameters
     */
    mergeCertificate(certificateName: string, x509Certificates: Uint8Array[], options?: MergeCertificateOptions): Promise<KeyVaultCertificateWithPolicy>;
    /**
     * Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.
     * This operation requires the certificates/backup permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * ```
     * Generates a backup of a certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    backupCertificate(certificateName: string, options?: BackupCertificateOptions): Promise<Uint8Array | undefined>;
    /**
     * Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * const poller = await client.beginDeleteCertificate("MyCertificate");
     * await poller.pollUntilDone();
     * // Some time is required before we're able to restore the certificate
     * await client.restoreCertificateBackup(backup!);
     * ```
     * Restores a certificate from a backup
     * @param backup - The back-up certificate to restore from
     * @param options - The optional parameters
     */
    restoreCertificateBackup(backup: Uint8Array, options?: RestoreCertificateBackupOptions): Promise<KeyVaultCertificateWithPolicy>;
    private listDeletedCertificatesPage;
    private listDeletedCertificatesAll;
    /**
     * Retrieves the certificates in the current vault which are in a deleted state and ready for recovery or purging. This operation includes deletion-specific
     * information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const deletedCertificate of client.listDeletedCertificates()) {
     *   console.log(deletedCertificate);
     * }
     * for await (const page of client.listDeletedCertificates().byPage()) {
     *   for (const deletedCertificate of page) {
     *     console.log(deletedCertificate);
     *   }
     * }
     * ```
     * Lists deleted certificates
     * @param options - The optional parameters
     */
    listDeletedCertificates(options?: ListDeletedCertificatesOptions): PagedAsyncIterableIterator<DeletedCertificate>;
    /**
     * retrieves the deleted certificate information plus its attributes, such as retention interval, scheduled permanent deletion and the
     * current deletion recovery level. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletedCertificate = await client.getDeletedCertificate("MyDeletedCertificate");
     * console.log("Deleted certificate:", deletedCertificate);
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getDeletedCertificate(certificateName: string, options?: GetDeletedCertificateOptions): Promise<DeletedCertificate>;
    /**
     * Performs an irreversible deletion of the specified certificate, without possibility for recovery. The operation is not available if the
     * recovery level does not specify 'Purgeable'. This operation requires the certificate/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     * // Deleting a certificate takes time, make sure to wait before purging it
     * client.purgeDeletedCertificate("MyCertificate");
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the deleted certificate to purge
     * @param options - The optional parameters
     */
    purgeDeletedCertificate(certificateName: string, options?: PurgeDeletedCertificateOptions): Promise<null>;
    /**
     * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.beginRecoverDeletedCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await recoverPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Recovers a deleted certificate
     * @param certificateName - The name of the deleted certificate
     * @param options - The optional parameters
     */
    beginRecoverDeletedCertificate(certificateName: string, options?: BeginRecoverDeletedCertificateOptions): Promise<PollerLike<RecoverDeletedCertificateState, KeyVaultCertificateWithPolicy>>;
}

/**
 * The optional parameters accepted by the KeyVault's CertificateClient
 */
export declare interface CertificateClientOptions extends ExtendedCommonClientOptions {
    /**
     * The accepted versions of the KeyVault's service API.
     */
    serviceVersion?: "7.0" | "7.1" | "7.2" | "7.3";
    /**
     * Whether to disable verification that the authentication challenge resource matches the Key Vault domain.
     * Defaults to false.
     */
    disableChallengeResourceVerification?: boolean;
}

/**
 * The contact information for the vault certificates.
 * Each contact will have at least just one of the properties of CertificateContactAll,
 * which are: emailAddress, name or phone.
 */
export declare type CertificateContact = RequireAtLeastOne<CertificateContactAll> | undefined;

/**
 * The shape of the contact information for the vault certificates.
 */
export declare interface CertificateContactAll {
    /**
     * Email address of the contact
     */
    email: string;
    /**
     * Name of the contact
     */
    name: string;
    /**
     * Phone number of the contact
     */
    phone: string;
}

/**
 * Defines values for contentType.
 * Possible values include: 'application/x-pem-file', 'application/x-pkcs12'
 * @readonly
 */
export declare type CertificateContentType = "application/x-pem-file" | "application/x-pkcs12" | undefined;

/**
 * An interface representing the properties of an issuer.
 */
export declare interface CertificateIssuer extends IssuerProperties {
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * When the issuer was created.
     */
    readonly createdOn?: Date;
    /**
     * When the issuer was updated.
     */
    readonly updatedOn?: Date;
    /**
     * The user name/account name/account id.
     */
    accountId?: string;
    /**
     * The password/secret/account key.
     */
    password?: string;
    /**
     * Id of the organization.
     */
    organizationId?: string;
    /**
     * Details of the organization's administrator contacts, as provided to the issuer.
     */
    administratorContacts?: AdministratorContact[];
}

/**
 * Defines values for JsonWebKeyCurveName. \
 * {@link KnownJsonWebKeyCurveName} can be used interchangeably with JsonWebKeyCurveName,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **P-256** \
 * **P-384** \
 * **P-521** \
 * **P-256K**
 */
export declare type CertificateKeyCurveName = string;

/**
 * Defines values for JsonWebKeyType. \
 * {@link KnownJsonWebKeyType} can be used interchangeably with JsonWebKeyType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **EC** \
 * **EC-HSM** \
 * **RSA** \
 * **RSA-HSM** \
 * **oct** \
 * **oct-HSM**
 */
export declare type CertificateKeyType = string;

/**
 * A certificate operation is returned in case of asynchronous requests.
 */
export declare interface CertificateOperation {
    /**
     * The certificate id.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly id?: string;
    /**
     * The name of certificate.
     */
    readonly name?: string;
    /**
     * Name of the referenced issuer object or reserved names; for example, 'Self' or 'Unknown'.
     */
    issuerName?: string;
    /**
     * Type of certificate to be requested from the issuer provider.
     */
    certificateType?: string;
    /**
     * Indicates if the certificates generated under this policy should be published to certificate
     * transparency logs.
     */
    certificateTransparency?: boolean;
    /**
     * The certificate signing request (CSR) that is being used in the certificate operation.
     */
    csr?: Uint8Array;
    /**
     * Indicates if cancellation was requested on the certificate operation.
     */
    cancellationRequested?: boolean;
    /**
     * Status of the certificate operation.
     */
    status?: string;
    /**
     * The status details of the certificate operation.
     */
    statusDetails?: string;
    /**
     * Error encountered, if any, during the certificate operation.
     */
    error?: CertificateOperationError;
    /**
     * Location which contains the result of the certificate operation.
     */
    target?: string;
    /**
     * Identifier for the certificate operation.
     */
    requestId?: string;
    /**
     * The vault URI.
     */
    readonly vaultUrl?: string;
}

/**
 * The key vault server error.
 */
export declare interface CertificateOperationError {
    /**
     * The error code.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly code?: string;
    /**
     * The error message.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly message?: string;
    /**
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly innerError?: CertificateOperationError;
}

/**
 * An interface representing the publicly available properties of the state of the CertificateOperationPoller.
 */
export declare interface CertificateOperationState extends KeyVaultCertificatePollOperationState<KeyVaultCertificateWithPolicy> {
    /**
     * The operation of the certificate
     */
    certificateOperation?: CertificateOperation;
}

/**
 * An type representing a certificate's policy with at least one of the subject properties.
 */
export declare type CertificatePolicy = CertificatePolicyProperties & RequireAtLeastOne<PolicySubjectProperties>;

/**
 * The action that will be executed.
 */
export declare type CertificatePolicyAction = "EmailContacts" | "AutoRenew";

/**
 * An interface representing a certificate's policy (without the subject properties).
 */
export declare interface CertificatePolicyProperties {
    /**
     * Indicates if the certificates generated under this policy should be published to certificate
     * transparency logs.
     */
    certificateTransparency?: boolean;
    /**
     * The media type (MIME type).
     *
     * Set to `application/x-pkcs12` when the certificate contains your PKCS#12/PFX bytes,
     * or to `application/x-pem-file` when the certificate contains your ASCII PEM-encoded bytes.
     */
    contentType?: CertificateContentType;
    /**
     * Type of certificate to be requested from the issuer provider.
     */
    certificateType?: string;
    /**
     * When the certificate was created.
     */
    readonly createdOn?: Date;
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Whether or not the certificate can be exported
     */
    exportable?: boolean;
    /**
     * The enhanced key usage.
     */
    enhancedKeyUsage?: string[];
    /**
     * Name of the referenced issuer object or reserved names; for example, 'Self' or 'Unknown'.
     */
    issuerName?: WellKnownIssuer | string;
    /**
     * Elliptic curve name. Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'
     */
    keyCurveName?: CertificateKeyCurveName;
    /**
     * The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     */
    keySize?: number;
    /**
     * The type of key pair to be used for the certificate. Possible values include: 'EC', 'EC-HSM',
     * 'RSA', 'RSA-HSM', 'oct'
     */
    keyType?: CertificateKeyType;
    /**
     * List of key usages.
     */
    keyUsage?: KeyUsageType[];
    /**
     * Actions that will be performed by Key Vault over the lifetime of a certificate.
     */
    lifetimeActions?: LifetimeAction[];
    /**
     * Indicates if the same key pair will be used on certificate renewal.
     */
    reuseKey?: boolean;
    /**
     * When the object was updated.
     */
    readonly updatedOn?: Date;
    /**
     * The duration that the certificate is valid in months.
     */
    validityInMonths?: number;
}

/**
 * An interface representing the optional parameters that can be
 * passed to {@link beginCreateCertificate}, {@link beginDeleteCertificate} and {@link beginRecoverDeletedCertificate}
 */
export declare interface CertificatePollerOptions extends coreClient.OperationOptions {
    /**
     * Time between each polling
     */
    intervalInMs?: number;
    /**
     * A serialized poller, used to resume an existing operation
     */
    resumeFrom?: string;
}

/**
 * An interface representing the properties of a certificate
 */
export declare interface CertificateProperties {
    /**
     * When the certificate was created.
     */
    readonly createdOn?: Date;
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * Expiry date in UTC.
     */
    readonly expiresOn?: Date;
    /**
     * Certificate identifier.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly id?: string;
    /**
     * The name of certificate.
     */
    readonly name?: string;
    /**
     * Not before date in UTC.
     */
    notBefore?: Date;
    /**
     * Reflects the deletion recovery level currently in effect for certificates in the current
     * vault. If it contains 'Purgeable', the certificate can be permanently deleted by a privileged
     * user; otherwise, only the system can purge the certificate, at the end of the retention
     * interval. Possible values include: 'Purgeable', 'Recoverable+Purgeable', 'Recoverable',
     * 'Recoverable+ProtectedSubscription'
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly recoveryLevel?: DeletionRecoveryLevel;
    /**
     * Application specific
     * metadata in the form of key-value pairs.
     */
    tags?: CertificateTags;
    /**
     * When the issuer was updated.
     */
    readonly updatedOn?: Date;
    /**
     * The vault URI.
     */
    readonly vaultUrl?: string;
    /**
     * The version of certificate. May be undefined.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly version?: string;
    /**
     * Thumbprint of the certificate.
     */
    readonly x509Thumbprint?: Uint8Array;
    /**
     * The retention dates of the softDelete data.
     * The value should be `>=7` and `<=90` when softDelete enabled.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    recoverableDays?: number;
}

/**
 * An interface representing the shape of the Certificate Tags. The tags are just string key-value pairs.
 */
export declare type CertificateTags = {
    [propertyName: string]: string;
};

/** The subject alternate names of a X509 object. */
export declare interface CoreSubjectAlternativeNames {
    /** Email addresses. */
    emails?: string[];
    /** Domain names. */
    dnsNames?: string[];
    /** User principal names. */
    upns?: string[];
}

/**
 * Options for {@link createCertificate}.
 */
export declare interface CreateCertificateOptions extends CertificateProperties, coreClient.OperationOptions {
}

/**
 * The public representation of the CreateCertificatePoller operation state.
 */
export declare type CreateCertificateState = KeyVaultCertificatePollOperationState<KeyVaultCertificateWithPolicy>;

/**
 * Options for {@link createIssuer}.
 */
export declare interface CreateIssuerOptions extends coreClient.OperationOptions {
    /**
     * The user name/account name/account id.
     */
    accountId?: string;
    /**
     * The password/secret/account key.
     */
    password?: string;
    /**
     * Id of the organization.
     */
    organizationId?: string;
    /**
     * Details of the organization's administrator contacts, as provided to the issuer.
     */
    administratorContacts?: AdministratorContact[];
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
}

/**
 * The DefaultCertificatePolicy exports values that
 * are useful as default parameters to methods that
 * modify the certificate's policy.
 */
export declare const DefaultCertificatePolicy: {
    issuerName: string;
    subject: string;
};

/**
 * Options for {@link deleteCertificateOperation}.
 */
export declare type DeleteCertificateOperationOptions = coreClient.OperationOptions;

/**
 * The public representation of the DeleteCertificatePoller operation state.
 */
export declare type DeleteCertificateState = KeyVaultCertificatePollOperationState<DeletedCertificate>;

/**
 * Options for {@link deleteContacts}.
 */
export declare type DeleteContactsOptions = coreClient.OperationOptions;

/**
 * An interface representing a deleted certificate.
 */
export declare interface DeletedCertificate extends KeyVaultCertificateWithPolicy {
    /**
     * The time when the certificate was deleted, in UTC
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly deletedOn?: Date;
    /**
     * The url of the recovery object, used to
     * identify and recover the deleted certificate.
     */
    readonly recoveryId?: string;
    /**
     * The time when the certificate is scheduled
     * to be purged, in UTC
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly scheduledPurgeDate?: Date;
}

/**
 * Options for {@link deleteIssuer}.
 */
export declare type DeleteIssuerOptions = coreClient.OperationOptions;

/**
 * Defines values for DeletionRecoveryLevel. \
 * {@link KnownDeletionRecoveryLevel} can be used interchangeably with DeletionRecoveryLevel,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Purgeable**: Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.) \
 * **Recoverable+Purgeable**: Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not recovered \
 * **Recoverable**: Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days, if not recovered \
 * **Recoverable+ProtectedSubscription**: Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself  cannot be permanently canceled. System wil permanently delete it after 90 days, if not recovered \
 * **CustomizedRecoverable+Purgeable**: Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is cancelled. \
 * **CustomizedRecoverable**: Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during the retention interval and while the subscription is still available. \
 * **CustomizedRecoverable+ProtectedSubscription**: Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects the fact that the subscription itself cannot be cancelled.
 */
export declare type DeletionRecoveryLevel = string;

/**
 * The key vault server error model.
 * @deprecated - Please use {@link CertificateOperationError} instead.
 */
export declare interface ErrorModel {
    /**
     * The error code.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly code?: string;
    /**
     * The error message.
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly message?: string;
    /**
     * **NOTE: This property will not be serialized. It can only be populated by the server.**
     */
    readonly innerError?: ErrorModel;
}

/**
 * Options for {@link getCertificateOperation}.
 */
export declare type GetCertificateOperationOptions = CertificatePollerOptions;

/**
 * Options for {@link getCertificate}.
 */
export declare type GetCertificateOptions = coreClient.OperationOptions;

/**
 * Options for {@link getCertificatePolicy}.
 */
export declare type GetCertificatePolicyOptions = coreClient.OperationOptions;

/**
 * Options for {@link getCertificateVersion}.
 */
export declare type GetCertificateVersionOptions = coreClient.OperationOptions;

/**
 * Options for {@link getContacts}.
 */
export declare type GetContactsOptions = coreClient.OperationOptions;

/**
 * Options for {@link getDeletedCertificate}.
 */
export declare type GetDeletedCertificateOptions = coreClient.OperationOptions;

/**
 * Options for {@link getIssuer}.
 */
export declare type GetIssuerOptions = coreClient.OperationOptions;

/**
 * Options for {@link getPlainCertificateOperation}.
 */
export declare type GetPlainCertificateOperationOptions = coreClient.OperationOptions;

/**
 * Options for {@link importCertificate}.
 */
export declare interface ImportCertificateOptions extends coreClient.OperationOptions {
    /**
     * Determines whether the object is enabled.
     */
    enabled?: boolean;
    /**
     * If the private key in base64EncodedCertificate is encrypted, the password used for encryption.
     */
    password?: string;
    /**
     * The management policy.
     */
    policy?: ImportCertificatePolicy;
    /**
     * Application specific
     * metadata in the form of key-value pairs.
     */
    tags?: CertificateTags;
}

/**
 * A type representing a certificate's policy for import which does not require a SAN or a Subject
 */
export declare type ImportCertificatePolicy = CertificatePolicyProperties & Partial<PolicySubjectProperties>;

/** The attributes of an issuer managed by the Key Vault service. */
export declare interface IssuerAttributes {
    /** Determines whether the issuer is enabled. */
    enabled?: boolean;
    /**
     * Creation time in UTC.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly created?: Date;
    /**
     * Last updated time in UTC.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly updated?: Date;
}

/** The credentials to be used for the certificate issuer. */
export declare interface IssuerCredentials {
    /** The user name/account name/account id. */
    accountId?: string;
    /** The password/secret/account key. */
    password?: string;
}

/** Parameters for the issuer of the X509 component of a certificate. */
export declare interface IssuerParameters {
    /** Name of the referenced issuer object or reserved names; for example, 'Self' or 'Unknown'. */
    name?: string;
    /** Certificate type as supported by the provider (optional); for example 'OV-SSL', 'EV-SSL' */
    certificateType?: string;
    /** Indicates if the certificates generated under this policy should be published to certificate transparency logs. */
    certificateTransparency?: boolean;
}

/**
 * An interface representing the properties of a certificate issuer
 */
export declare interface IssuerProperties {
    /**
     * Certificate Identifier.
     */
    id?: string;
    /**
     * Name of the issuer.
     */
    readonly name?: string;
    /**
     * The issuer provider.
     */
    provider?: string;
}

/**
 * Defines values for KeyUsageType. \
 * {@link KnownKeyUsageType} can be used interchangeably with KeyUsageType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **digitalSignature** \
 * **nonRepudiation** \
 * **keyEncipherment** \
 * **dataEncipherment** \
 * **keyAgreement** \
 * **keyCertSign** \
 * **cRLSign** \
 * **encipherOnly** \
 * **decipherOnly**
 */
export declare type KeyUsageType = string;

/**
 * An interface representing a certificate without the certificate's policy
 */
export declare interface KeyVaultCertificate {
    /**
     * CER contents of x509 certificate.
     */
    cer?: Uint8Array;
    /**
     * Certificate identifier.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    id?: string;
    /**
     * The key id.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly keyId?: string;
    /**
     * The secret id.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly secretId?: string;
    /**
     * The name of certificate.
     */
    readonly name: string;
    /**
     * The properties of the certificate
     */
    properties: CertificateProperties;
}

/**
 * Represents the segments that compose a Key Vault Certificate Id.
 */
export declare interface KeyVaultCertificateIdentifier {
    /**
     * The complete representation of the Key Vault Certificate Id. For example:
     *
     *   https://<keyvault-name>.vault.azure.net/certificates/<certificate-name>/<unique-version-id>
     *
     */
    sourceId: string;
    /**
     * The URL of the Azure Key Vault instance to which the Certificate belongs.
     */
    vaultUrl: string;
    /**
     * The version of Key Vault Certificate. Might be undefined.
     */
    version?: string;
    /**
     * The name of the Key Vault Certificate.
     */
    name: string;
}

/**
 * An interface representing the public shape of the state of a Key Vault Certificate Poller's operations.
 */
export declare interface KeyVaultCertificatePollOperationState<TResult> extends PollOperationState<TResult> {
    /**
     * The name of the certificate.
     */
    certificateName: string;
}

/**
 * An interface representing a certificate with its policy
 */
export declare interface KeyVaultCertificateWithPolicy extends KeyVaultCertificate {
    /**
     * The management policy.
     * **NOTE: This property will not be serialized. It can only be populated by
     * the server.**
     */
    readonly policy?: CertificatePolicy;
}

/** Known values of {@link CertificateKeyCurveName} that the service accepts. */
export declare enum KnownCertificateKeyCurveNames {
    /**
     * P-256 Key Curve.
     */
    P256 = "P-256",
    /**
     * P-384 Key Curve.
     */
    P384 = "P-384",
    /**
     * P-521 Key Curve.
     */
    P521 = "P-521",
    /**
     * P-256K Key Curve.
     */
    P256K = "P-256K"
}

/** Known values of {@link CertificateKeyType} that the service accepts. */
export declare enum KnownCertificateKeyTypes {
    /**
     * EC Key Type.
     */
    EC = "EC",
    /**
     * EC-HSM Key Type.
     */
    ECHSM = "EC-HSM",
    /**
     * RSA Key Type.
     */
    RSA = "RSA",
    /**
     * RSA-HSM Key Type.
     */
    RSAHSM = "RSA-HSM",
    /**
     * oct Key Type
     */
    Oct = "oct",
    /**
     * oct-HSM Key Type
     */
    OctHSM = "oct-HSM"
}

/** Known values of {@link DeletionRecoveryLevel} that the service accepts. */
export declare enum KnownDeletionRecoveryLevels {
    /** Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.) */
    Purgeable = "Purgeable",
    /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not recovered */
    RecoverablePurgeable = "Recoverable+Purgeable",
    /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days, if not recovered */
    Recoverable = "Recoverable",
    /** Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself  cannot be permanently canceled. System wil permanently delete it after 90 days, if not recovered */
    RecoverableProtectedSubscription = "Recoverable+ProtectedSubscription",
    /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is cancelled. */
    CustomizedRecoverablePurgeable = "CustomizedRecoverable+Purgeable",
    /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during the retention interval and while the subscription is still available. */
    CustomizedRecoverable = "CustomizedRecoverable",
    /** Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects the fact that the subscription itself cannot be cancelled. */
    CustomizedRecoverableProtectedSubscription = "CustomizedRecoverable+ProtectedSubscription"
}

/** Known values of {@link KeyUsageType} that the service accepts. */
export declare enum KnownKeyUsageTypes {
    /**
     * DigitalSignature Usage Type.
     */
    DigitalSignature = "digitalSignature",
    /**
     * NonRepudiation Usage Type.
     */
    NonRepudiation = "nonRepudiation",
    /**
     * KeyEncipherment Usage Type.
     */
    KeyEncipherment = "keyEncipherment",
    /**
     * DataEncipherment Usage Type.
     */
    DataEncipherment = "dataEncipherment",
    /**
     * KeyAgreement Usage Type.
     */
    KeyAgreement = "keyAgreement",
    /**
     * KeyCertSign Usage Type.
     */
    KeyCertSign = "keyCertSign",
    /**
     * CRLSign Usage Type.
     */
    CRLSign = "cRLSign",
    /**
     * EncipherOnly Usage Type.
     */
    EncipherOnly = "encipherOnly",
    /**
     * DecipherOnly Usage Type.
     */
    DecipherOnly = "decipherOnly"
}

/**
 * Deprecated KeyVault copy of core-lro's PollerLike.
 */
export declare type KVPollerLike<TState extends PollOperationState<TResult>, TResult> = PollerLike<TState, TResult>;

/**
 * Action and its trigger that will be performed by Key Vault over the lifetime of a certificate.
 */
export declare interface LifetimeAction {
    /**
     * Percentage of lifetime at which to trigger. Value should be between 1 and 99.
     */
    lifetimePercentage?: number;
    /**
     * Days before expiry to attempt renewal. Value should be between 1 and validity_in_months
     * multiplied by 27. If validity_in_months is 36, then value should be between 1 and 972 (36 *
     * 27).
     */
    daysBeforeExpiry?: number;
    /**
     * The action that will be executed.
     */
    action?: CertificatePolicyAction;
}

/**
 * An interface representing optional parameters for CertificateClient paged operations passed to {@link listDeletedCertificates}.
 */
export declare interface ListDeletedCertificatesOptions extends coreClient.OperationOptions {
    /**
     * Specifies whether to include certificates which are not completely provisioned.
     */
    includePending?: boolean;
}

/**
 * An interface representing optional parameters for CertificateClient paged operations passed to {@link listPropertiesOfCertificates}.
 */
export declare interface ListPropertiesOfCertificatesOptions extends coreClient.OperationOptions {
    /**
     * Specifies whether to include certificates which are not completely provisioned.
     */
    includePending?: boolean;
}

/**
 * An interface representing optional parameters for CertificateClient paged operations passed to {@link listPropertiesOfCertificateVersions}.
 */
export declare type ListPropertiesOfCertificateVersionsOptions = coreClient.OperationOptions;

/**
 * An interface representing optional parameters for CertificateClient paged operations passed to {@link listPropertiesOfIssuers}.
 */
export declare type ListPropertiesOfIssuersOptions = coreClient.OperationOptions;

/**
 * The \@azure/logger configuration for this package.
 */
export declare const logger: AzureLogger;

/**
 * An interface representing optional parameters for {@link mergeCertificate}.
 */
export declare type MergeCertificateOptions = coreClient.OperationOptions;

/**
 * Parses the given Key Vault Certificate Id. An example is:
 *
 *   https://<keyvault-name>.vault.azure.net/certificates/<certificate-name>/<unique-version-id>
 *
 * On parsing the above Id, this function returns:
 *```ts
 *   {
 *      sourceId: "https://<keyvault-name>.vault.azure.net/certificates/<certificate-name>/<unique-version-id>",
 *      vaultUrl: "https://<keyvault-name>.vault.azure.net",
 *      version: "<unique-version-id>",
 *      name: "<certificate-name>"
 *   }
 *```
 * @param id - The Id of the Key Vault Certificate.
 */
export declare function parseKeyVaultCertificateIdentifier(id: string): KeyVaultCertificateIdentifier;

/**
 * An interface representing the possible subject properties of a certificate's policy.
 * The final type requires at least one of these properties to exist.
 */
export declare interface PolicySubjectProperties {
    /**
     * The subject name. Should be a valid X509 distinguished Name.
     */
    subject: string;
    /**
     * The subject alternative names.
     */
    subjectAlternativeNames: SubjectAlternativeNames;
}

export { PollerLike }

/**
 * Options for {@link purgeDeletedCertificate}.
 */
export declare type PurgeDeletedCertificateOptions = coreClient.OperationOptions;

/**
 * Deprecated: Public representation of the recovery of a deleted certificate poll operation
 */
export declare type RecoverDeletedCertificateState = KeyVaultCertificatePollOperationState<KeyVaultCertificateWithPolicy>;

/**
 * RequireAtLeastOne helps create a type where at least one of the properties of an interface (can be any property) is required to exist.
 *
 * This works because of TypeScript's utility types: https://www.typescriptlang.org/docs/handbook/utility-types.html
 * Let's examine it:
 * - `[K in keyof T]-?` this property (K) is valid only if it has the same name as any property of T.
 * - `Required<Pick<T, K>>` makes a new type from T with just the current property in the iteration, and marks it as required
 * - `Partial<Pick<T, Exclude<keyof T, K>>>` makes a new type with all the properties of T, except from the property K.
 * - `&` is what unites the type with only one required property from `Required<...>` with all the optional properties from `Partial<...>`.
 * - `[keyof T]` ensures that only properties of T are allowed.
 */
export declare type RequireAtLeastOne<T> = {
    [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>;
}[keyof T];

/**
 * An interface representing optional parameters for {@link restoreCertificateBackup}.
 */
export declare type RestoreCertificateBackupOptions = coreClient.OperationOptions;

/**
 * Options for {@link setContacts}.
 */
export declare type SetContactsOptions = coreClient.OperationOptions;

/**
 * Alternatives to the subject property.
 * If present, it should at least have one of the properties of SubjectAlternativeNamesAll.
 */
export declare type SubjectAlternativeNames = RequireAtLeastOne<SubjectAlternativeNamesAll>;

/**
 * An interface representing the alternative names of the subject of a certificate policy.
 */
export declare interface SubjectAlternativeNamesAll {
    /**
     * Email addresses.
     */
    emails: ArrayOneOrMore<string>;
    /**
     * Domain names.
     */
    dnsNames: ArrayOneOrMore<string>;
    /**
     * User principal names.
     */
    userPrincipalNames: ArrayOneOrMore<string>;
}

/**
 * Options for {@link updateCertificate}.
 */
export declare interface UpdateCertificateOptions extends CertificateProperties, coreClient.OperationOptions {
}

/**
 * Options for {@link updateCertificatePolicy}.
 */
export declare type UpdateCertificatePolicyOptions = coreClient.OperationOptions;

/**
 * Options for {@link updateIssuer}.
 */
export declare interface UpdateIssuerOptions extends CreateIssuerOptions {
    /**
     * The issuer provider.
     */
    provider?: string;
}

/**
 * Well known issuers for choosing a default
 */
export declare enum WellKnownIssuer {
    /**
     * For self signed certificates
     */
    Self = "Self",
    /**
     * For certificates whose issuer will be defined later
     */
    Unknown = "Unknown"
}

/** Properties of the X509 component of a certificate. */
export declare interface X509CertificateProperties {
    /** The subject name. Should be a valid X509 distinguished Name. */
    subject?: string;
    /** The enhanced key usage. */
    ekus?: string[];
    /** The subject alternative names. */
    subjectAlternativeNames?: CoreSubjectAlternativeNames;
    /** List of key usages. */
    keyUsage?: KeyUsageType[];
    /** The duration that the certificate is valid in months. */
    validityInMonths?: number;
}

export { }
