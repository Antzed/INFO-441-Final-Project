// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { cleanState, KeyVaultCertificatePollOperation, } from "../keyVaultCertificatePoller";
import { getCertificateOperationFromCoreOperation, getCertificateWithPolicyFromCertificateBundle, } from "../../transformations";
import { tracingClient } from "../../tracing";
/**
 * An interface representing the active operation of a certificate's creation,
 * which is represented locally as the "operation" of an active LRO Poller.
 */
export class CertificateOperationPollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state);
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * Cancels a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
     */
    cancelCertificateOperation(certificateName, options = {}) {
        return tracingClient.withSpan("CertificateOperationPoller.cancelCertificateOperation", options, async (updatedOptions) => {
            let parsedBody;
            await this.client.updateCertificateOperation(this.vaultUrl, certificateName, true, Object.assign(Object.assign({}, updatedOptions), { onResponse: (response) => {
                    parsedBody = response.parsedBody;
                } }));
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, parsedBody);
        });
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     */
    getCertificate(certificateName, options = {}) {
        return tracingClient.withSpan("CertificateOperationPoller.getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets the certificate operation.
     */
    getPlainCertificateOperation(certificateName, options = {}) {
        return tracingClient.withSpan("CertificateOperationPoller.getPlainCertificateOperation", options, async (updatedOptions) => {
            let parsedBody;
            await this.client.getCertificateOperation(this.vaultUrl, certificateName, Object.assign(Object.assign({}, updatedOptions), { onResponse: (response) => {
                    parsedBody = response.parsedBody;
                } }));
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const certificateName = state.certificateName;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            state.isStarted = true;
            state.result = await this.getCertificate(certificateName, this.operationOptions);
            state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        else if (!state.isCompleted) {
            state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        if (state.certificateOperation && state.certificateOperation.status !== "inProgress") {
            state.isCompleted = true;
            state.result = await this.getCertificate(certificateName, this.operationOptions);
            if (state.certificateOperation.error) {
                state.error = new Error(state.certificateOperation.error.message);
            }
        }
        return this;
    }
    /**
     * Reaches to the service and cancels the certificate's operation, also updating the poll operation.
     */
    async cancel(options = {}) {
        const state = this.state;
        const certificateName = state.certificateName;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        state.certificateOperation = await this.cancelCertificateOperation(certificateName, this.operationOptions);
        this.state.isCancelled = true;
        return this;
    }
    /**
     * Serializes the certificate's poll operation
     */
    toString() {
        const state = Object.assign({ certificateOperation: this.state.certificateOperation }, cleanState(this.state));
        return JSON.stringify({
            state,
        });
    }
}
//# sourceMappingURL=operation.js.map