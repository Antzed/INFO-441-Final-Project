// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { tracingClient } from "../../tracing";
import { getCertificateWithPolicyFromCertificateBundle } from "../../transformations";
import { KeyVaultCertificatePollOperation, } from "../keyVaultCertificatePoller";
/**
 * An interface representing the recovery of a deleted certificate's poll operation
 */
export class RecoverDeletedCertificatePollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state, {
            cancelMessage: "Canceling the recovery of a deleted certificate is not supported.",
        });
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     */
    getCertificate(certificateName, options = {}) {
        return tracingClient.withSpan("RecoverDeletedCertificatePoller.getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation
     * requires the certificate/recover permission.
     */
    recoverDeletedCertificate(certificateName, options = {}) {
        let parsedBody;
        return tracingClient.withSpan("RecoverDeletedCertificatePoller.recoverDeletedCertificate", options, async (updatedOptions) => {
            await this.client.recoverDeletedCertificate(this.vaultUrl, certificateName, Object.assign(Object.assign({}, updatedOptions), { onResponse: (response) => {
                    parsedBody = response.parsedBody;
                } }));
            return getCertificateWithPolicyFromCertificateBundle(parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const { certificateName } = state;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            try {
                state.result = await this.getCertificate(certificateName, this.operationOptions);
                state.isCompleted = true;
            }
            catch (e) {
                // getCertificate will only work once the LRO is completed.
            }
            if (!state.isCompleted) {
                state.result = await this.recoverDeletedCertificate(certificateName, this.operationOptions);
                state.isStarted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = await this.getCertificate(certificateName, this.operationOptions);
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                    throw error;
                }
            }
        }
        return this;
    }
}
//# sourceMappingURL=operation.js.map